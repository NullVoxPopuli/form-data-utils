{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["type FormDataEntryValue = NonNullable<ReturnType<FormData['get']>>;\ntype Data = { [key: string]: FormDataEntryValue[] | FormDataEntryValue | string[] | number | Date | File | File[] | unknown | unknown[] | null };\n\n/**\n * A utility function for extracting the FormData as an object\n */\nexport function dataFrom(\n  /**\n   * The submit event from the event listener on the form.\n   * The currentTarget must be a `<form>`\n   *\n   *\n   * Each input within your `<form>` should have a `name` attribute.\n   * (or else the `<form>` element doesn't know what inputs are relevant)\n   */\n  event: {\n    currentTarget: EventTarget | null,\n    submitter?: HTMLElement | null | undefined\n  },\n): Data {\n  if (!event) {\n    throw new Error(`Cannot call dataFrom with no event`);\n  }\n\n  if (!(event.currentTarget instanceof HTMLFormElement)) {\n    throw new Error(\n      `Cannot pass dataFrom an object where the currentTarget property's value is not a form`,\n    );\n  }\n\n  const form = event.currentTarget;\n  const formData = new FormData(form, event.submitter);\n  const data: Data = Object.fromEntries(formData.entries());\n\n  for (const field of form.elements) {\n    const name = field.getAttribute('name');\n\n    // The field is probably invalid\n    if (!name) continue;\n\n    const hasSubmitted = name in data;\n\n    // Default to null, because by default FormData does not include fields\n    // that were not checked. We exclude buttons, because their value should only\n    // be added if they're pressed.\n    if (!hasSubmitted && !(field instanceof HTMLButtonElement)) data[name] = null;\n\n    // If the field is a `select`, we need to better\n    // handle the value, since only the most recently\n    // clicked will be available\n    if (field instanceof HTMLSelectElement) {\n      data[field.name] = getSelectValue(field);\n    } else if (field instanceof HTMLButtonElement && hasSubmitted) {\n      // normalize empty valued buttons to null. Only consider buttons that were submitted (default forms behavior)\n      data[field.name] = field.value || null;\n    } else if (field instanceof HTMLInputElement) {\n      const _related = form.querySelectorAll(`[name=\"${name}\"]`)\n      const related = Array.from(_related) as HTMLInputElement[];\n\n      if (!(related.every(x => x instanceof HTMLInputElement))) {\n        throw new Error(`Every element with name ${name} must be an input`);\n      }\n\n      const hasMultipleValues = related.length > 1;\n\n      /**\n        * By default, all input values are strings.\n        * So we need to normalize the types returned to the user.\n        */\n      switch (field.type) {\n        case 'number':\n        case 'range': {\n          data[field.name] = isNaN(field.valueAsNumber) ? null : field.valueAsNumber;\n\n          break;\n        }\n        case 'date': {\n          data[field.name] = field.valueAsDate;\n\n          break;\n        }\n        case 'datetime-local': {\n          // datetime-local inputs do not have a `valueAsDate`, but they do have a `valueAsNumber`\n          // which is the number of milliseconds since January 1, 1970, UTC\n          // - to mimic input[type=\"date\"], we return null when input is not filled (`valueAsNumber` is NaN)\n          // - when `valueAsNumber` is a number, we create a new date with its value\n          data[field.name] = isNaN(field.valueAsNumber) ? null : new Date(field.valueAsNumber);\n\n          break;\n        }\n        case 'checkbox': {\n          if (hasMultipleValues) {\n            data[field.name] = related.filter(x => x.checked).map(x => getRadioCheckboxValue(x));\n          } else {\n            data[field.name] = getRadioCheckboxValue(field);\n          }\n\n          break;\n        }\n        case 'radio': {\n          let radio: HTMLInputElement | undefined;\n\n          if (hasMultipleValues) {\n            radio = related.find(x => x.checked);\n          } else {\n            radio = field;\n          }\n\n          data[field.name] = radio ? getRadioCheckboxValue(radio) : null;\n\n          break;\n        }\n        case 'file': {\n          if (field.files && field.files.length > 0) {\n            data[field.name] = field.multiple ? Array.from(field.files) : field.files[0] || null;\n          } else {\n            data[field.name] = field.multiple ? [] : null;\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  return data;\n}\n\nfunction getSelectValue(field: HTMLSelectElement) {\n  return field.multiple ? getMultipleSelectValue(field) : getSingleSelectValue(field);\n}\n\nfunction getSingleSelectValue(field: HTMLSelectElement) {\n  // avoid looping if we know nothing is selected\n  if (field.selectedIndex === -1) return null;\n\n  let optionValue: unknown = null;\n\n  for (let opt of field.options) {\n    if (!opt.disabled && opt.selected) {\n      optionValue = getOptionValue(opt);\n    }\n  }\n\n  return optionValue;\n}\n\nfunction getMultipleSelectValue(field: HTMLSelectElement) {\n  // avoid looping if we know nothing is selected\n  if (field.selectedIndex === -1) return [];\n\n  let optionValues: unknown[] = [];\n\n  for (let opt of field.options) {\n    if (!opt.disabled && opt.selected && opt.value !== '') {\n      optionValues.push(getOptionValue(opt));\n    }\n  }\n\n  return optionValues;\n}\n\nfunction getOptionValue(opt: HTMLOptionElement) {\n  if (!opt.disabled && opt.selected) {\n    // we normalize empty string to null\n    if (opt.value === '') return null;\n\n    return getValue(opt) || opt.value;\n  }\n}\n\nfunction getRadioCheckboxValue(el: HTMLInputElement) {\n  if (el.disabled) return;\n\n  // if radio or checkbox were not supplied any value, we assume the user wants a boolean\n  // el.getAttribute('value') returns null when value is not supplied (el.value returns 'on', so we can't use it)\n  const isValueDefined = el.getAttribute('value') !== null || getValue(el);\n\n  if (!isValueDefined) return getValue(el) || el.checked;\n\n  if (el.checked) {\n    return getValue(el) || el.value;\n  }\n\n  return null;\n}\n\n// utils to allow setting non-primitive values\n\nconst values: WeakMap<Element, unknown> = new WeakMap();\n\nexport function setValue(element: HTMLElement, value: unknown) {\n  values.set(element, value);\n}\n\nexport function deleteValue(element: HTMLElement) {\n  return values.delete(element);\n}\n\nfunction getValue(element: HTMLElement) {\n  return values.get(element);\n}\n"],"names":[],"mappings":"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"}